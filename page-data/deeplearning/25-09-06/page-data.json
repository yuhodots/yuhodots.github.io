{"componentChunkName":"component---src-templates-post-js","path":"/deeplearning/25-09-06/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p>이 글은 Anthropic의 엔지니어링 블로그 포스트 \"<a href=\"https://www.anthropic.com/engineering/building-effective-agents\">Building effective agents</a>\"와 \"<a href=\"https://www.anthropic.com/engineering/multi-agent-research-system\">Multi-agent research system</a>\"를 번역 &#x26; 정리한 글입니다. 개인 공부를 목적으로 번역하여 아래에 기록하였으며, Gemini 2.5 Pro 기반으로 초벌 번역을 진행하고 검수를 통해 글을 정리하였습니다. 해당 글들은 에이전트를 공부하시는 분들에게는 필독서와 같은 포스트이니 꼭 읽어보시는 것을 추천드립니다. 각 LLM workflow와 Agent에 대한 시각화 자료는 <a href=\"https://www.anthropic.com/engineering/building-effective-agents\">원문</a>에서 확인하실 수 있습니다.</p>\n</blockquote>\n<h3 id=\"agentic-system\" style=\"position:relative;\"><a href=\"#agentic-system\" aria-label=\"agentic system permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Agentic System?</h3>\n<p>에이전틱 시스템(Agentic System)은 단순히 대규모 언어 모델(LLM)을 호출하는 것을 넘어, LLM을 핵심 추론 엔진으로 활용하여 복잡하고 여러 단계에 걸친 목표를 자율적으로 달성하는 시스템을 의미합니다. 기존의 모델 활용 방식과 에이전틱 시스템을 구분하는 핵심적인 특징은 <strong>자율성(autonomy)</strong>, <strong>목표 지향성(goal-orientation)</strong>, 그리고 사전 정의된 <strong>도구(tools)</strong>를 통해 외부 세계와 상호작용하는 능력입니다.</p>\n<p>에이전트는 정해진 루프(loop) 안에서 작동합니다. 먼저 주어진 목표를 평가하고, 이를 달성하기 위한 일련의 행동 계획을 수립합니다. 그 후, 계획에 따라 도구를 호출하는 등의 행동을 실행하고, 그 결과를 관찰합니다. 에이전트는 이 새로운 정보를 바탕으로 기존의 계획을 수정하거나 새로운 계획을 세웁니다. 이러한 반복적인 프로세스를 통해 단일하고 정적인 프롬프트로는 해결하기 어려운 복잡한 과업을 효과적으로 처리할 수 있습니다.</p>\n<p>이러한 변화는 프로그래밍 패러다임의 근본적인 전환을 의미합니다. 기존의 LLM 호출이 입력을 제공하고 출력을 받는 함수 호출과 유사했다면, 에이전틱 시스템은 상위 수준의 목표를 위임하는 것과 같습니다. 개발자는 더 이상 \"<strong>어떻게</strong>\"를 지시하는 상세한 명령어를 작성하는 것이 아니라, \"<strong>무엇을</strong>\" 달성해야 하는지를 명시합니다.</p>\n<h5 id=\"workflows-vs-agents\" style=\"position:relative;\"><a href=\"#workflows-vs-agents\" aria-label=\"workflows vs agents permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Workflows vs. Agents</h5>\n<p>\"Agent\"는 여러 가지 방식으로 정의될 수 있습니다. 일부 고객들은 에이전트를 다양한 도구를 사용해 복잡한 작업을 수행하며 장기간 독립적으로 작동하는 완전히 자율적인 시스템으로 정의합니다. 반면, 어떤 고객들은 미리 정의된 워크플로우를 따르는 보다 규범적인 구현을 가리키는 데 이 용어를 사용합니다. Anthropic에서는 이러한 모든 변형을 <strong>에이전트 시스템(agentic systems)</strong>으로 분류하지만, <strong>워크플로우</strong>와 <strong>에이전트</strong> 사이에 중요한 아키텍처적 구분을 둡니다:</p>\n<ul>\n<li><strong>워크플로우(Workflows)</strong>란 LLM과 도구들이 미리 정해진 코드 경로(코드 플로우)를 통해 오케스트레이션되는 시스템입니다.</li>\n<li><strong>에이전트(Agents)</strong>는 반면에, LLM이 자신이 어떻게 과업을 수행할지, 어떤 도구를 사용할지 등을 스스로 동적으로 결정하면서 전체 과정을 주도적으로 제어하는 시스템입니다.</li>\n</ul>\n<h5 id=\"언제-agent를-사용해야-하는가\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-agent%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\" aria-label=\"언제 agent를 사용해야 하는가 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 'Agent'를 사용해야 하는가?</h5>\n<p>에이전틱 시스템의 도입이 특히 유리한 문제 유형은 다음과 같은 특징을 가집니다.</p>\n<ul>\n<li><strong>실행 경로를 예측할 수 없는 task</strong>: 문제 해결에 필요한 정확한 단계를 사전에 모두 정의하거나 하드코딩하기 어려운 경우에 적합합니다. 예를 들어, 완전히 새로운 소프트웨어 버그를 디버깅하거나, 정답이 정해지지 않은 개방형 연구를 수행하는 경우가 이에 해당합니다.</li>\n<li><strong>외부 환경과의 상호작용이 필요한 task</strong>: 실시간 정보에 접근(웹 검색, 데이터베이스 쿼리)하거나 외부 시스템의 상태를 변경(이메일 발송, CRM 업데이트)해야 하는 작업에 필수적입니다.</li>\n<li><strong>장기적이고 여러 단계로 구성된 프로세스</strong>: 한 단계의 출력이 다음 단계의 입력으로 사용되는 긴 의존성 체인을 가진 과업을 처리하는 데 효과적입니다.</li>\n<li><strong>동적인 적응이 요구되는 task</strong>: 시스템이 새로운 정보에 반응하여 중간에 전략을 수정해야 하는 경우, 에이전트의 자율적인 계획 수정 능력은 매우 중요합니다.</li>\n</ul>\n<h5 id=\"1-building-block-the-augmented-llm\" style=\"position:relative;\"><a href=\"#1-building-block-the-augmented-llm\" aria-label=\"1 building block the augmented llm permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Building block: The augmented LLM</h5>\n<p>Augmented LLM은 모든 에이전틱 시스템의 가장 기본적인 구성 단위입니다. 이는 Claude와 같은 <strong>LLM에 외부 도구(tools) 세트가 결합된 형태</strong>입니다. 이 시스템의 작동 메커니즘은 다음과 같습니다. LLM은 사용자의 질의뿐만 아니라 사용 가능한 도구 목록과 그에 대한 설명을 함께 프롬프트로 입력받습니다. 모델은 자신의 추론 능력을 사용하여 사용자의 요청을 이행하기 위해 특정 도구를 언제, 어떻게 호출해야 할지를 결정합니다.</p>\n<h5 id=\"2-workflow-prompt-chaining\" style=\"position:relative;\"><a href=\"#2-workflow-prompt-chaining\" aria-label=\"2 workflow prompt chaining permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Workflow: Prompt chaining</h5>\n<p>Prompt chaining은 가장 단순한 워크플로우로, <strong>한 LLM 호출의 출력이 프로그래밍 방식으로 다음 LLM 호출의 입력으로 사용되는 구조</strong>입니다. 이는 선형적이고 순차적인 작업 흐름을 생성합니다. \"이 텍스트를 번역한 후, 번역된 내용을 요약하라\"와 같이 고정된 일련의 변환 작업으로 분해할 수 있는 과업에 이상적입니다.</p>\n<h5 id=\"3-workflow-routing\" style=\"position:relative;\"><a href=\"#3-workflow-routing\" aria-label=\"3 workflow routing permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Workflow: Routing</h5>\n<p>Routing은 프롬프트 체이닝에 조건부 논리를 도입하여 발전시킨 형태입니다. <strong>초기 LLM 호출이 '라우터' 역할을 하여 입력을 분석하고, 여러 가능한 다음 단계나 도구 중 어느 것을 호출할지 결정</strong>합니다. 고객 지원 시스템에서 초기 질의를 분석하여 청구 관련 부서 도구, 기술 지원 도구, 또는 일반 FAQ 도구로 연결하는 사례가 대표적입니다.</p>\n<h5 id=\"4-workflow-parallelization\" style=\"position:relative;\"><a href=\"#4-workflow-parallelization\" aria-label=\"4 workflow parallelization permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Workflow: Parallelization</h5>\n<p>Parallelization는 속도와 처리 범위를 넓히기 위해 설계된 워크플로우입니다. <strong>단일 질의를 여러 개의 독립적인 하위 질의로 분해하여, 별도의 LLM 호출을 통해 동시에 실행</strong>할 수 있습니다. 예를 들어, \"원자력 에너지에 대한 주요 찬반 논거는 무엇인가?\"와 같은 광범위한 주제를 조사할 때, \"찬성 논거\", \"반대 논거\", \"경제적 영향\", \"환경적 영향\" 등으로 나누어 병렬적으로 검색을 수행할 수 있습니다.</p>\n<h5 id=\"5-workflow-orchestrator-workers\" style=\"position:relative;\"><a href=\"#5-workflow-orchestrator-workers\" aria-label=\"5 workflow orchestrator workers permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Workflow: Orchestrator-workers</h5>\n<p>Orchestrator-workers는 <strong>중앙의 '오케스트레이터' 에이전트가 복잡한 과업을 분석하고, 이를 더 작고 전문화된 하위 과업으로 분해한 뒤, 각 하위 과업을 전담 '워커' 에이전트에게 위임</strong>합니다. 워커들은 각자 독립된 컨텍스트와 특화된 도구를 가지고 병렬적으로 작업을 수행한 후, 그 결과를 오케스트레이터에게 보고합니다. <strong>오케스트레이터는 이 결과들을 종합하여 최종적인 일관된 답변을 생성</strong>합니다</p>\n<h5 id=\"6-workflow-evaluator-optimizer\" style=\"position:relative;\"><a href=\"#6-workflow-evaluator-optimizer\" aria-label=\"6 workflow evaluator optimizer permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Workflow: Evaluator-optimizer</h5>\n<p>Evaluator-optimizer 워크플로우는 <strong>반복적인 개선을 위한 피드백 루프를 도입</strong>합니다. 하나의 에이전트('워커' 또는 '생성자')가 코드나 이메일 초안과 같은 결과물을 생성하면, 두 번째 에이전트('평가자' 또는 '비평가')가 이 결과물을 정해진 기준이나 루브릭에 따라 평가하고 피드백을 제공합니다. 그러면 워커는 이 피드백을 바탕으로 개선된 버전을 다시 생성합니다.</p>\n<h5 id=\"7-agents\" style=\"position:relative;\"><a href=\"#7-agents\" aria-label=\"7 agents permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Agents</h5>\n<p>진정한 의미의 '에이전트'는 위에서 설명한 Building block과 Workflow를 동적으로 결합하는 시스템으로 정의됩니다. 에이전트는 단일 워크플로우에 국한되지 않고, 장기간에 걸쳐 상위 수준의 목표를 달성하기 위해 상황에 맞는 적절한 워크플로우(또는 워크플로우의 조합)를 자율적으로 선택하고 실행하는 주체입니다.</p>\n<h3 id=\"agents-in-practice\" style=\"position:relative;\"><a href=\"#agents-in-practice\" aria-label=\"agents in practice permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Agents in practice</h3>\n<h5 id=\"a-customer-support\" style=\"position:relative;\"><a href=\"#a-customer-support\" aria-label=\"a customer support permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A. Customer support</h5>\n<p>고객 지원 에이전트는 지식 베이스 접근, CRM에서 고객 이력 조회, 지원 티켓 생성 및 업데이트와 같은 도구를 갖출 수 있습니다. 이 에이전트는 <strong>Routing</strong> 워크플로우를 활용할 수 있습니다. 고객의 문의를 받으면 먼저 지식 베이스를 검색합니다. 만약 적절한 답변을 찾지 못하면, 문의 내용의 키워드를 분석하여 올바른 담당자에게 배정될 지원 티켓을 생성하는 도구를 호출합니다.</p>\n<h5 id=\"b-coding-agents\" style=\"position:relative;\"><a href=\"#b-coding-agents\" aria-label=\"b coding agents permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>B. Coding agents</h5>\n<p>코딩 에이전트는 파일 읽기/쓰기, 샌드박스 환경에서 코드 실행, 린터나 정적 분석 도구 접근과 같은 도구를 부여받을 수 있습니다. 이 에이전트는 <strong>Evaluator-optimizer</strong> 워크플로우를 사용할 수 있습니다. 사용자가 \"이 함수를 더 효율적으로 리팩토링해 줘\"라고 요청하면, 에이전트는 새로운 버전의 코드를 작성하고('워커'), 성능 테스트를 실행합니다('평가자'). 만약 새로운 버전이 더 빠르지 않다면, 에이전트는 테스트 결과를 분석하여 다른 접근법을 시도하며, 성능 목표가 충족될 때까지 이 과정을 반복합니다.</p>\n<h3 id=\"prompt-engineering-your-tools\" style=\"position:relative;\"><a href=\"#prompt-engineering-your-tools\" aria-label=\"prompt engineering your tools permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prompt engineering your tools</h3>\n<p>에이전트와 도구(tool) 간의 인터페이스는 인간과 컴퓨터 간의 인터페이스만큼이나 중요합니다. 도구의 효과는 단순히 그 기능에 의해서만 결정되는 것이 아니라, 프롬프트 내에서 그 목적과 사용법이 에이전트에게 얼마나 명확하게 설명되는지에 따라 크게 달라집니다. Anthropic은 다음과 같은 실용적인 휴리스틱을 제시합니다.</p>\n<ul>\n<li><strong>명시적인 가이드라인 제공</strong>: 에이전트에게 도구 선택 방법에 대한 명확한 지침을 제공해야 합니다. 예를 들어, \"사용 가능한 경우 일반적인 도구보다 전문화된 도구를 우선적으로 사용하라\" 또는 \"광범위한 외부 탐색이 필요할 때는 항상 웹 검색 도구부터 시작하라\"와 같은 지침을 포함할 수 있습니다.</li>\n<li><strong>탐색 장려</strong>: 과업 시작 시 에이전트가 사용 가능한 모든 도구를 검토하도록 지시하여 더 나은 초기 계획을 수립하도록 유도합니다.</li>\n<li><strong>사용자 의도와 도구 사용의 일치</strong>: 프롬프트는 도구 사용을 단순히 함수 목록으로 나열하는 것이 아니라, 사용자의 문제를 해결하는 맥락 안에서 구성해야 합니다.</li>\n<li><strong>Claude를 프롬프트 엔지니어로 활용</strong>: 모델 자체를 활용하여 도구 관련 프롬프트를 개선할 수 있습니다. 특정 프롬프트와 실패 사례를 모델에게 제공하고, 에이전트가 왜 실패했는지 진단하고 도구 설명이나 사용 지침에 대한 개선 사항을 제안하도록 요청할 수 있습니다.</li>\n</ul>\n<h3 id=\"benefits-of-a-multi-agent-system\" style=\"position:relative;\"><a href=\"#benefits-of-a-multi-agent-system\" aria-label=\"benefits of a multi agent system permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Benefits of a multi-agent system</h3>\n<p>다중 에이전트 아키텍처는 단일 에이전트 시스템을 넘어서는 여러 가지 뚜렷한 이점을 제공하며, 이는 Anthropic의 research agent 시스템에서 명확히 드러납니다.</p>\n<ul>\n<li><strong>개방형 문제 해결</strong>: 다중 에이전트 시스템은 정답으로 가는 경로가 미리 알려지지 않은 연구 과업에서 탁월한 성능을 보입니다. 오케스트레이터는 다른 에이전트가 발견한 흥미로운 단서를 조사하기 위해 새로운 에이전트를 동적으로 생성할 수 있습니다.</li>\n<li><strong>유연성 및 적응성</strong>: 시스템은 중간 결과에 따라 접근 방식을 조정하고 예상치 못한 관련성을 탐색하는 등, 인간 연구자가 정보를 발견하며 연구 방향을 수정하는 것과 유사하게 작동할 수 있습니다.</li>\n<li><strong>압축(Compression)</strong>: 이는 다중 에이전트 시스템의 핵심적인 이점입니다. 각 워커 에이전트는 자신의 컨텍스트 창 내에서 깊이 있는 탐색을 수행한 후, 가장 중요한 정보만을 '압축'하여 오케스트레이터에게 간결한 요약 형태로 전달합니다. 이를 통해 시스템 전체는 단일 모델의 컨텍스트 한계를 훨씬 뛰어넘는 방대한 양의 정보를 처리하고 종합할 수 있습니다.</li>\n<li><strong>관심사 분리(Separation of Concerns)</strong>: 각 하위 에이전트는 고유한 프롬프트, 도구, 지침을 가질 수 있어 전문화된 전문가 역할을 수행합니다. 이는 단일 에이전트가 서로 상충하는 지침으로 인해 혼란을 겪을 위험을 줄이고, 시스템 전체의 견고성을 향상시킵니다.</li>\n<li><strong>성능 확장</strong>: 특정 유형의 과업, 특히 광범위하고 병렬적인 조사가 필요한 경우, 다중 에이전트 시스템은 단일 모델의 지능만으로는 달성하기 어려운 수준으로 성능을 확장하는 핵심적인 방법이 됩니다.</li>\n<li><strong>토큰 사용량 증가 (노력의 대리 지표)</strong>: Anthropic의 분석에 따르면, 복잡한 브라우징 과업의 성능 분산 중 80%가 사용된 토큰의 양만으로 설명될 수 있었습니다. 다중 에이전트 시스템은 문제에 더 많은 연산 노력(즉, 더 많은 토큰 사용)을 효과적이고 병렬적으로 투입할 수 있는 구조화된 방법을 제공하여 더 높은 품질의 결과를 이끌어 냅니다.</li>\n</ul>\n<p>특히 '압축'이라는 이점은 LLM의 근본적인 제약 조건인 유한한 컨텍스트 창 문제에 대한 직접적이고 우아한 해결책을 제시합니다. 단일 LLM은 한 번에 처리할 수 있는 정보의 양에 명백한 한계가 있습니다. 복잡한 연구 과제는 이 한계를 훌쩍 뛰어넘는 수십, 수백 개의 소스로부터 정보를 종합해야 합니다. 다중 에이전트 시스템은 이 문제를 병렬화하여 해결합니다.</p>\n<p>예를 들어, 10개의 에이전트가 각각 5개의 문서를 자신의 컨텍스트 창 안에서 완벽하게 소화합니다. 각 에이전트는 이 5개 문서의 핵심 내용을 지능적으로 '압축'하여 요약 보고서를 생성합니다. 최종적으로 오케스트레이터는 이 10개의 요약 보고서만을 읽으면 되는데, 이는 오케스트레이터의 컨텍스트 창 안에 충분히 들어갈 수 있는 분량입니다. 이 아키텍처는 LLM을 단순히 정보의 한 '페이지'를 분석하는 도구에서, 전체 '도서관'을 효과적으로 읽고 종합할 수 있는 시스템으로 변모시킵니다.</p>\n<h3 id=\"architecture-overview-for-research\" style=\"position:relative;\"><a href=\"#architecture-overview-for-research\" aria-label=\"architecture overview for research permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Architecture overview for Research</h3>\n<p>Anthropic의 연구 에이전트는 <strong>Orchestrator-workers</strong> 패턴을 구체적으로 구현한 사례입니다. 그 실행 흐름은 다음과 같습니다.</p>\n<ol>\n<li><strong>질의 제출</strong>: 사용자가 복잡한 연구 질의를 시스템에 제출합니다.</li>\n<li><strong>분해 및 전략 수립</strong>: 선행하는 '오케스트레이터' 에이전트가 질의를 분석하고, 이를 3-5개의 병렬 실행 가능한 하위 과업으로 분해하며, 연구 전략을 수립합니다.</li>\n<li><strong>위임</strong>: 오케스트레이터는 여러 전문 '워커' 하위 에이전트를 생성하고, 각 에이전트에게 명확한 목표, 요구되는 결과물 형식, 그리고 웹 검색과 같은 필요한 도구 세트를 제공합니다.</li>\n<li><strong>병렬 실행</strong>: 워커 에이전트들은 각자의 과업을 동시에 수행하며, 독립적으로 도구를 사용하여 정보를 수집하고 분석합니다.</li>\n<li><strong>종합</strong>: 각 워커는 구조화된 형태의 연구 결과를 오케스트레이터에게 반환합니다.</li>\n<li><strong>최종 보고서 작성</strong>: 오케스트레이터는 모든 워커로부터 받은 입력 내용을 종합하고, 상충되는 정보가 있다면 해결하며, 최종적으로 포괄적인 답변을 작성하여 사용자에게 제공합니다.</li>\n</ol>\n<h3 id=\"effective-evaluation-of-agents\" style=\"position:relative;\"><a href=\"#effective-evaluation-of-agents\" aria-label=\"effective evaluation of agents permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Effective evaluation of agents</h3>\n<p>상태를 가지며 비결정적으로 작동하는 에이전틱 시스템을 평가하고 상용 환경에 배포하는 것은 기존 소프트웨어와는 다른 독특하고 중대한 과제를 수반합니다. 먼저, 엔지니어링 측면에서 해결해야 할 문제들이 있습니다.에이전트는 장기간 상태를 유지하며 작동하기 때문에, 초기에 발생한 사소한 오류가 시간이 지나면서 누적되어 결국 전체 과업의 실패로 이어질 수 있습니다. 따라서 견고한 <strong>오류 처리 및 복구 메커니즘</strong>이 필수적입니다. 또한, 동일한 프롬프트와 입력에 대해서도 실행할 때마다 다른 경로를 택할 수 있는 비결정성 때문에, 전통적인 디버깅 방식으로 실패를 재현하고 원인을 파악하기가 매우 어렵습니다. 이는 <strong>로깅, 관찰 가능성, 통계적 평가</strong> 중심으로의 전환을 요구합니다. 마지막으로, 이미 실행 중인 에이전트 시스템에 업데이트를 배포하는 것은 매우 복잡합니다. 개별 에이전트들이 다단계 프로세스의 각기 다른 지점에 있을 수 있기 때문입니다.</p>\n<p>이러한 특성은 평가 전략에도 영향을 미칩니다.예를 들어, 여러 턴에 걸쳐 코드 베이스를 수정하는 코딩 에이전트를 평가할 때, 각 중간 단계의 품질을 점수화하는 것보다 최종 결과물의 품질, 즉 <strong>최종 상태를 평가</strong>하는 것이 더 의미 있고 신뢰할 수 있습니다. 또한, 상용 환경의 에이전트는 수백 턴에 달하는 긴 대화에 참여할 수 있으므로, 중요한 정보를 보존하면서 컨텍스트 창의 한계를 넘지 않도록 하는 정교한 컨텍스트 관리 전략(요약, 벡터 DB 검색 등)이 필요합니다. 이러한 엔지니어링 과제들은 에이전틱 AI가 단순히 머신러닝의 연장선이 아니라, 새로운 소프트웨어 엔지니어링 분야의 시작임을 시사합니다. 'AgentOps' 또는 'AIOps'로 불릴 수 있는 새로운 종류의 도구 스택을 필요로 합니다.</p>\n<h3 id=\"appendix-handoff-vs-tool\" style=\"position:relative;\"><a href=\"#appendix-handoff-vs-tool\" aria-label=\"appendix handoff vs tool permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Appendix: Handoff vs. Tool</h3>\n<p>추가적으로 OpenAI Agent SDK를 많이 다뤄 보신 분께서 조언을 해주신 것이 있는데, 개인적으로 handoff와 tool을 이해하는데 큰 도움이 되었어서 아래에 기록합니다. </p>\n<ul>\n<li>\n<p>Handoff는 특정 작업의 주도권을 아예 다른 에이전트에게 넘겨버리는 것임. 이전에 수행했던 LLM/유저 사이의 conversation 기록을 모두 copy &#x26; paste 하여 다른 에이전트에게 넘기는 것이고 이에 따라 시스템 프롬프트나 사용 가능한 tool들이 변경됨</p>\n<ul>\n<li>만약 특정 conversation만 필터링해서 넘기고 싶다면 그 때에 input filter와 옵션을 활용해서 컨텍스트를 일부만 넘길 수 있음</li>\n</ul>\n</li>\n<li>Agent as tool은 에이전트가 특정 작업만 다른 sub agent에게 넘겨서 처리하고, 그 결과물을 다시 받아서 활용하고 싶을 때 사용. 따라서 아주 특정 conversation 맥락만 sub agent에게 공유되고, 주도권은 여전히 중앙 에이전트가 가짐</li>\n<li>이러한 이유로 생각보다 handoff를 사용해서 에이전트를 구축할 일은 많지 않고 agent as tool을 많이 쓰게 됨</li>\n</ul>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<ul>\n<li><a href=\"https://www.anthropic.com/engineering/building-effective-agents\">https://www.anthropic.com/engineering/building-effective-agents</a></li>\n<li><a href=\"https://www.anthropic.com/engineering/multi-agent-research-system\">https://www.anthropic.com/engineering/multi-agent-research-system</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#agentic-system\">Agentic System?</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#workflows-vs-agents\">Workflows vs. Agents</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#%EC%96%B8%EC%A0%9C-agent%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80\">언제 'Agent'를 사용해야 하는가?</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#1-building-block-the-augmented-llm\">1. Building block: The augmented LLM</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#2-workflow-prompt-chaining\">2. Workflow: Prompt chaining</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#3-workflow-routing\">3. Workflow: Routing</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#4-workflow-parallelization\">4. Workflow: Parallelization</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#5-workflow-orchestrator-workers\">5. Workflow: Orchestrator-workers</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#6-workflow-evaluator-optimizer\">6. Workflow: Evaluator-optimizer</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#7-agents\">7. Agents</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#agents-in-practice\">Agents in practice</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#a-customer-support\">A. Customer support</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#b-coding-agents\">B. Coding agents</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#prompt-engineering-your-tools\">Prompt engineering your tools</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#benefits-of-a-multi-agent-system\">Benefits of a multi-agent system</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#architecture-overview-for-research\">Architecture overview for Research</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#effective-evaluation-of-agents\">Effective evaluation of agents</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#appendix-handoff-vs-tool\">Appendix: Handoff vs. Tool</a></li>\n<li><a href=\"/MachineLearning/25-09-06-Anthropic%20Agent/#references\">References</a></li>\n</ul>","frontmatter":{"path":"/deeplearning/25-09-06/","title":"Anthropic의 에이전트 설계 노하우","category":"Deep Learning","date":"2025-09-06"}}},"pageContext":{}},"staticQueryHashes":["2390655019","256249292","63159454"]}